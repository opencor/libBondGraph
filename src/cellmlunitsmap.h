/*******************************************************************************

Copyright (C) The University of Auckland

OpenCOR is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenCOR is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://gnu.org/licenses>.

*******************************************************************************/

#pragma once

#include "Exceptions.h"
#include "thirdparty/tinyxml2.h"
#include <algorithm>
#include <cctype>
#include <map>
#include <sstream>
#include <string>
#include <tuple>
#include <units.hpp>
#include <unordered_map>
#include <vector>

// Let the compiler know that the string is defined in a cxx file. The file is
// generated by cmake.
extern const char *cellmlunits;
namespace BG {

class CellMLUnits {
private:
  std::unordered_map<std::string, units::precise_unit> dimensions;
  std::unordered_map<std::string, std::string> existingNames;
  std::unordered_map<std::string, std::string> mappedDimensionName;
  std::string predefinedunitsXML;

public:
  inline std::string trim(const std::string &s) {
    auto wsfront = std::find_if_not(s.begin(), s.end(),
                                    [](int c) { return std::isspace(c); });
    auto wsback = std::find_if_not(s.rbegin(), s.rend(), [](int c) {
                    return std::isspace(c);
                  }).base();
    return (wsback <= wsfront ? std::string() : std::string(wsfront, wsback));
  }

  CellMLUnits() {
    predefinedunitsXML = std::string(cellmlunits);
    tinyxml2::XMLDocument doc;
    tinyxml2::XMLPrinter printer;
    std::ostringstream ss;
    if (doc.Parse(predefinedunitsXML.c_str()) == tinyxml2::XML_SUCCESS) {
      tinyxml2::XMLElement *pRootElement = doc.RootElement();
      if (pRootElement != nullptr) {
        // Get 'Units'
        tinyxml2::XMLElement *units = pRootElement->FirstChildElement("units");
        while (units) {
          std::vector<units::precise_unit> subUnits;
          std::string unitName = trim(units->Attribute("name"));
          // Get 'unit' Child
          tinyxml2::XMLElement *unit = units->FirstChildElement("unit");

          while (unit) {
            std::string lunit;
            std::string expon = "1";
            std::string prefix = "";
            for (const tinyxml2::XMLAttribute *attr = unit->FirstAttribute();
                 attr != 0; attr = attr->Next()) {
              auto an = trim(attr->Name());
              auto av = trim(attr->Value());
              if (an == "units") {
                // Sometimes units definitions use prior definitions
                if (dimensions.find(av) != dimensions.end()) {
                  lunit = units::to_string(dimensions[av]);
                } else {
                  lunit = units::to_string(units::unit_from_string(av));
                }
              } else if (an == "exponent")
                expon = av;
              else if (an == "prefix")
                prefix = av;
            }
            ss.str("");
            ss.clear();

            if (expon != "1") {
              ss << "(" << prefix << " " << lunit << ")^" << expon;
            } else {
              ss << prefix << " " << lunit;
            }
            subUnits.push_back(units::unit_from_string(ss.str()));
            unit = unit->NextSiblingElement("unit");
          }

          units::precise_unit unitDef = subUnits[0];
          for (int ix = 1; ix < subUnits.size(); ix++) {
            unitDef = unitDef * subUnits[ix];
          }
          auto mult = unitDef.multiplier();
          auto baseU = unitDef.base_units();
          auto preciseunit = units::precise_unit(baseU, mult);
          dimensions[unitName] = preciseunit;
          // existingNames[preciseunit] = unitName;
          existingNames[units::to_string(preciseunit)] = unitName;
          // std::cout<<unitName<<"\t"<<units::to_string(preciseunit)<<std::endl;
          // Next Units def
          units = units->NextSiblingElement("units");
        }
      }
    } else {
      throw BGException(
          "Error creating CellML document from ");
    }
  };

  std::string getPredefinedunitsXML() { return predefinedunitsXML; }

  std::string getUnitName(const std::string &unit) {
    // units::precise_unit unit = units::unit_from_string(unitStr);
    if (existingNames.find(unit) != existingNames.end()) {
      return existingNames[unit];
    }
    // WASM doesnt handle exceptions well, so returing a unique string
    return "UNIT_NAME_NOT_FOUND";
    // throw BGException("Name for unit " + unit + " not found");
  }

  std::tuple<std::string, std::string, units::precise_unit>
  getCellMLDef(const std::string &unit) {
    units::precise_unit unitDef = units::unit_from_string(unit);
    auto mult = unitDef.multiplier();
    auto baseU = unitDef.base_units();
    std::vector<std::string> unitl;
    std::ostringstream ss;
    ss << "";
    if (mult != 1.0) {
      ss << "multiplier=\"" << mult << "\"";
    }
    std::string multiplier = ss.str();
    ss.str("");
    ss.clear();
    // Check for Cellml standard units
    bool cellmlbaseunitfound = false;
    std::string basesiunit = units::to_string(units::precise_unit(baseU));
    if (basesiunit == "V") {
      basesiunit = "volt";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "A") {
      basesiunit = "ampere";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "F") {
      basesiunit = "farad";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "C") {
      basesiunit = "coulomb";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "C") {
      basesiunit = "coulomb";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "1/S") {
      basesiunit = "ohm";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "S") {
      basesiunit = "siemens";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "K") {
      basesiunit = "kelvin";
      cellmlbaseunitfound = true;
    } else if (basesiunit == "mol") {
      basesiunit = "mole";
      cellmlbaseunitfound = true;
    }

    if (cellmlbaseunitfound) {
      if (mult != 1.0) {
        unitl.push_back("<unit " + multiplier + " units=\"" + basesiunit +
                        "\" />");
      } else {
        unitl.push_back("<unit units=\"" + basesiunit + "\" />");
      }
    } else {
      if (baseU.meter() != 0) {
        std::string mx = multiplier;
        if (baseU.meter() < 0) {
          mx = "";
        }
        if (baseU.meter() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.meter()) +
                          "\" units=\"metre\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"metre\" />");
        }
        if (baseU.meter() > 0) {
          multiplier = "";
        }
      }
      if (baseU.kg() != 0) {
        std::string mx = multiplier;
        if (baseU.kg() < 0) {
          mx = "";
        }
        if (baseU.kg() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.kg()) +
                          "\" units=\"kilogram\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"kilogram\" />");
        }
        if (baseU.kg() > 0) {
          multiplier = "";
        }
      }
      if (baseU.second() != 0) {
        std::string mx = multiplier;
        if (baseU.second() < 0) {
          mx = "";
        }
        if (baseU.second() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.second()) +
                          "\" units=\"second\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"second\" />");
        }
        if (baseU.second() > 0) {
          multiplier = "";
        }
      }
      if (baseU.ampere() != 0) {
        std::string mx = multiplier;
        if (baseU.ampere() < 0) {
          mx = "";
        }
        if (baseU.ampere() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.ampere()) +
                          "\" units=\"ampere\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"ampere\" />");
        }
        if (baseU.ampere() > 0) {
          multiplier = "";
        }
      }
      if (baseU.kelvin() != 0) {
        std::string mx = multiplier;
        if (baseU.kelvin() < 0) {
          mx = "";
        }
        if (baseU.kelvin() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.kelvin()) +
                          "\" units=\"kelvin\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"kelvin\" />");
        }
        if (baseU.kelvin() > 0) {
          multiplier = "";
        }
      }
      if (baseU.mole() != 0) {
        std::string mx = multiplier;
        if (baseU.mole() < 0) {
          mx = "";
        }
        if (baseU.mole() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.mole()) +
                          "\" units=\"mole\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"mole\" />");
        }
        if (baseU.mole() > 0) {
          multiplier = "";
        }
      }
      if (baseU.candela() != 0) {
        std::string mx = multiplier;
        if (baseU.candela() < 0) {
          mx = "";
        }
        if (baseU.candela() != 1) {
          unitl.push_back("<unit " + mx + " exponent=\"" +
                          std::to_string(baseU.candela()) +
                          "\" units=\"candela\" />");
        } else {
          unitl.push_back("<unit " + mx + " units=\"candela\" />");
        }
        if (baseU.candela() > 0) {
          multiplier = "";
        }
      }
    }
    std::string uname = unit;
    bool isStandardUnit = false;
    if (mappedDimensionName.find(unit) == mappedDimensionName.end()) {
      std::string llnlname = units::to_string(unitDef);
      if (llnlname == "V") {
        uname = "volt";
        isStandardUnit = true;
      } else if (llnlname == "A") {
        uname = "ampere";
        isStandardUnit = true;
      } else if (llnlname == "F") {
        uname = "farad";
        isStandardUnit = true;
      } else if (llnlname == "C") {
        uname = "coulomb";
        isStandardUnit = true;
      } else if (llnlname == "C") {
        uname = "coulomb";
        isStandardUnit = true;
      } else if (llnlname == "1/S") {
        uname = "ohm";
        isStandardUnit = true;
      } else if (llnlname == "S") {
        uname = "siemens";
        isStandardUnit = true;
      } else if (llnlname == "K") {
        uname = "kelvin";
        isStandardUnit = true;
      } else if (llnlname == "mol") {
        uname = "mole";
        isStandardUnit = true;
      } else {
        uname = unit;
        // Definition does not exist
        if (existingNames.find(unit) == existingNames.end()) {
          std::replace(uname.begin(), uname.end(), '-', 'n');
          // Replace any _, ^
          size_t pos = 0;
          while ((pos = uname.find("/", pos)) != std::string::npos) {
            uname.replace(pos, 1, "_per_");
            pos += 5;
          }
          pos = 0;
          while ((pos = uname.find("^", pos)) != std::string::npos) {
            uname.replace(pos, 1, "_pow_");
            pos += 5;
          }
          // Replace operators
          std::replace_if(
              uname.begin(), uname.end(),
              [](auto ch) { return std::ispunct(ch); }, '_');
          std::replace(uname.begin(), uname.end(), ' ', '_');
          if (std::isdigit(uname[0])) {
            if (uname[0] == '1') {
              uname[0] = 'I';
            } else {
              uname[0] = 'D';
            }
          }
        }
        uname = replaceAll(uname, "__", "_");
        // std::cout<<uname<<std::endl;
      }
      mappedDimensionName[unit] = uname;
    } else {
      uname = mappedDimensionName[unit];
    }
    if (!isStandardUnit) {
      ss << "<units name=\"" << uname << "\">" << std::endl;
      for (auto c : unitl) {
        ss << "\t" << c << std::endl;
      }
      ss << "</units>" << std::endl;
    }
    if (uname == "NaN_ERROR") {
      std::cout << __FILE__ << " " << __LINE__ << "\n"
                << uname << "\t" << unit << std::endl;
    }
    std::string res = ss.str();
    return std::make_tuple(uname, res, unitDef);
  }
};
} // namespace BG
